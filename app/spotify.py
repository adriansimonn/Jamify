import requests
from flask import current_app

def searchForPlaylists(accessToken, keywords):
    searchURL = "https://api.spotify.com/v1/search"
    headers = {"Authorization": f"Bearer {accessToken}"}
    playlists = []
    for k in keywords:
        parameters = {"q": k, "type": "playlist", "limit": 5}
        response = requests.get(searchURL, headers=headers, params=parameters)
        if response.status_code == 200:
            playlists.extend(response.json().get("playlists", {}).get("items", []))
        else:
            print("Error with Spotify API")
            return None
    return playlists

def getPotentialTracks(accessToken, playlists, numSongs):
    tracks = {}
    size = min(numSongs, 100)
    for p in playlists:
        if not isinstance(p, dict):  # Check if `p` is a valid playlist dictionary
            print(f"Skipping invalid playlist entry: {p}")
            continue

        playlistID = p.get("id")  # Safely access `id`
        if not playlistID:
            print(f"Skipping playlist with no ID: {p}")
            continue

        tracksURL = f"https://api.spotify.com/v1/playlists/{playlistID}/tracks"
        headers = {"Authorization": f"Bearer {accessToken}"}
        response = requests.get(tracksURL, headers=headers)
        if response.status_code == 200:
            for item in response.json().get("items", []):
                track = item.get("track")
                if track:
                    trackID = track.get("id")
                    if trackID:
                        tracks[trackID] = tracks.get(trackID, 0) + 1
        else:
            print(f"Error fetching tracks for playlist {playlistID}: {response.status_code}")
    
    return sorted(tracks, key=tracks.get, reverse=True)[:size]

def getTokenFromCode(code):
    tokenUrl = "https://accounts.spotify.com/api/token"
    apiData = {
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": current_app.config['REDIRECT_URI'],
        "client_id": current_app.config['CLIENT_ID'],
        "client_secret": current_app.config['CLIENT_SECRET'],
    }
    response = requests.post(tokenUrl, data=apiData)
    return response.json().get('access_token')

def getPreviewURLS(access_token):
    headers = {"Authorization": f"Bearer {access_token}"}
    playlistUrl = "https://api.spotify.com/v1/me/playlists"
    response = requests.get(playlistUrl, headers=headers).json()

    preview_urls = []
    for playlist in response['items']:
        tracksUrl = playlist['tracks']['href']
        tracks = requests.get(tracksUrl, headers=headers).json()
        for track in tracks['items']:
            preview_url = track['track'].get('preview_url')
            if preview_url:
                preview_urls.append(preview_url)
    return preview_urls

def getUserID(accessToken):
    url = "https://api.spotify.com/v1/me"
    headers = {"Authorization": f"Bearer {accessToken}"}
    response = requests.get(url, headers=headers)
    if response.status_code != 200:
        print(f"Error fetching user ID: {response.status_code}, {response.text}")
        return None
    userID = response.json().get("id")
    print(f"Fetched User ID: {userID}")
    return userID


def createTempPlaylist(accessToken, userID):
    url = f"https://api.spotify.com/v1/users/{userID}/playlists"
    headers = {"Authorization": f"Bearer {accessToken}"}
    data = {
        "name": "Generated Playlist",
        "description": "A temporary playlist for previewing. Generated by Jamify",
        "public": False
    }
    response = requests.post(url, headers=headers, json=data)
    if response.status_code != 201:
        print(f"Error creating playlist: {response.status_code}, {response.text}")
        return None
    playlistID = response.json().get("id")
    print(f"Created Playlist ID: {playlistID}")
    return playlistID

def addTracksToPlaylist(accessToken, playlistID, trackURIs):
    url = f"https://api.spotify.com/v1/playlists/{playlistID}/tracks"
    headers = {"Authorization": f"Bearer {accessToken}"}
    data = {"uris": trackURIs}
    response = requests.post(url, headers=headers, json=data)
    if response.status_code != 201:
        print(f"Error adding tracks to playlist: {response.status_code}, {response.text}")
    else:
        print(f"Tracks added successfully to playlist {playlistID}")

def getAllGenres():
    validGenres = [
        "acoustic", "afrobeat", "alt-rock", "alternative", "ambient", "anime", "black-metal",
        "bluegrass", "blues", "bossanova", "brazil", "breakbeat", "british", "cantopop",
        "chicago-house", "children", "chill", "classical", "club", "comedy", "country",
        "dance", "dancehall", "death-metal", "deep-house", "detroit-techno", "disco",
        "disney", "drum-and-bass", "dub", "dubstep", "edm", "electro", "electronic",
        "emo", "folk", "forro", "french", "funk", "garage", "german", "gospel", "goth",
        "grindcore", "groove", "grunge", "guitar", "happy", "hard-rock", "hardcore",
        "hardstyle", "heavy-metal", "hip-hop", "holidays", "honky-tonk", "house",
        "idm", "indian", "indie", "indie-pop", "industrial", "iranian", "j-dance",
        "j-idol", "j-pop", "j-rock", "jazz", "k-pop", "kids", "latin", "latino",
        "malay", "mandopop", "metal", "metal-misc", "metalcore", "minimal-techno",
        "movies", "mpb", "new-age", "new-release", "opera", "pagode", "party", "philippines-opm",
        "piano", "pop", "pop-film", "post-dubstep", "power-pop", "progressive-house",
        "psych-rock", "punk", "punk-rock", "r-n-b", "rainy-day", "reggae", "reggaeton",
        "road-trip", "rock", "rock-n-roll", "rockabilly", "romance", "sad", "salsa",
        "samba", "sertanejo", "show-tunes", "singer-songwriter", "ska", "sleep", "songwriter",
        "soul", "soundtracks", "spanish", "study", "summer", "swedish", "synth-pop",
        "tango", "techno", "trance", "trip-hop", "turkish", "work-out", "world-music"
    ]
    return validGenres

def getArtistID(accessToken, artistName):
    url = f"https://api.spotify.com/v1/search?q={artistName}&type=artist"
    headers = {"Authorization": f"Bearer {accessToken}"}
    response = requests.get(url, headers=headers)
    items = response.json().get("artists", {}).get("items", [])
    return items[0]["id"] if items else None

def getTrackID(accessToken, trackName):
    url = f"https://api.spotify.com/v1/search?q={trackName}&type=track&limit=1"
    headers = {"Authorization": f"Bearer {accessToken}"}
    response = requests.get(url, headers=headers).json()
    items = response.get("tracks", {}).get("items", [])
    return items[0]["id"] if items else None

def test_spotify_api(accessToken):
    headers = {
        "Authorization": f"Bearer {accessToken}",
        "Accept": "application/json"
    }
    
    # Test endpoints
    endpoints = {
        "Me": "https://api.spotify.com/v1/me",
        "New Releases": "https://api.spotify.com/v1/browse/new-releases"
    }
    
    for name, url in endpoints.items():
        try:
            response = requests.get(url, headers=headers)
            print(f"\n{name} Endpoint:")
            print(f"URL: {url}")
            print(f"Status Code: {response.status_code}")
            print(f"Headers: {response.headers}")
            print(f"Response: {response.text[:200]}...")  # First 200 chars of response
        except Exception as e:
            print(f"Error testing {name} endpoint: {e}")